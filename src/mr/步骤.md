先明白worker要干啥
然后再想coordinator
### worker
- 请求一个task
  - 处理不同的taskType
- 完成这个task
  - map：读文件，
    - 调用自定义的map函数，
    - 分成n个reduce桶(文件)，
    - 用json形式写到文件(注意文件命名)中
  - reduce：知道所有worker的collect结果或者fileName
    - 解码自己负责的桶
    - merge起来
    - 排序
    - 找相同的key，call reduce
    - 写入文件
- report task结果给coordinator，继续请求

### coordinator
- 回应worker对于task的请求
  - 检查是否有超时的task => 重新分配
  - 面对变量
    - 是否done了
    - TaskType要哪个
    - map/reduce被分配完了还没执行完
  - Map/Reduce需要的metadata
    - map：filename 
    - reduce：
  - 更新状态
    - Task

- 处理task所返回的结果
  - 更新Task Status

- 知道什么时候结束进程
  - 通知worker退出

把coordinator的struct写出来，要解决所有需求

Task
// info needed to execute
- taskType: Map/Reduce
- fileName
// metadata to help coordinator keep track of it
- TaskId
- WorkerId
- Status

Coordinator
- mutex
- Tasks
- mapDoneCount
- nReduce(就是有多少个partition)
- done
- fileNames


解决RPC调用的参数


// Lab 2 KV Server
- Put(key, value, version)
  - if keyNotFound
    - version == 0 => create version++
    - version > 0 => rpc.ErrNoKey 
  - if keyFound
    - version == currVersion => execute Put
    - version != rpc.ErrVersion

- Get(key)
  - if keyFound
    - return key
  - else
    - rpc.ErrNoKey

- linearizability

why using client server model







































